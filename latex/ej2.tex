
\section{Ejercicio 2}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
	\subsection{Descripción del problema}

	$N$ soldados de Freezer estan parados en distintos puntos $(X_i,Y_i)$ sobre
	nuestro planeta y estan dispuestos a acabar con toda la humanidad. Para
	esto, Gokú desea lanzarles Genkidamas para acabar con ellos. Los puntos
	cumplen con la propiedad $ X_1 > X_2 >. . . > X_N \geq 0 $ y $ 0 \leq Y_1 <
	Y_2 < . . . < Y_N$. Una Genkidama lanzada al objetivo con coordenadas $(X,Y)$
	destruye a todos los enemigos que estan en el rectángulo con lados paralelos
	a los ejes y extremos en $(0, 0)$ y $(X + T, Y + T )$. Sólo pueden lanzarse
	Genkidamas a puntos donde hay o hubo un enemigo. 

	La solución al problema debe tomar un $N$ correspondiente a la cantidad de adversarios,
	$T$ el alcance de la Genkidama, y por último las posiciones de los enemigos
	de Gokú. Con estos datos calculará a qué enemigos lanzarles una
	Genkidama para requerir las mínimas posibles.

	La salida consiste en un $G$ que representa la cantidad de Genkidamas
	seguido de una línea con los índices de los adversarios a los cuáles se
	les lanzó alguna.

	Este es un ejemplo de una entrada con su respectiva
	solución:

	~

	\textbf{Entrada}

	\begin{tabular}{ll}
		\texttt{3} & \texttt{2} \\
		\texttt{4} & \texttt{0} \\
		\texttt{3} & \texttt{3} \\
		\texttt{1} & \texttt{6} \\
	\end{tabular}

	~

	\textbf{Salida}

	\begin{tabular}{ll}
		\texttt{2} & \\
		\texttt{2} & \texttt{3} \\
	\end{tabular}

	~

	Se puede observar que tenemos 3 oponentes ($N$), el rango de la
	Genkidama es 2 ($T$) y se necesitaron 2 de ellas para vencerlos ($G$). En este caso, al
	dispararle a 2 se estaba también destruyendo a 1, quedando fuera del alcance
	y por ende destinado a ser exterminado aparte 3.

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}
        Si tirara un genkidama a cada enemigo eso solucionaria el problema de matar a todos los enemigos, pero solo seria solucion optima si todos los enemigos estuviesen a una distancia mayor a $\sqrt{2}T$ , ya que cada enemigo tendria una diferencia mayor a $T$ con respecto a las coordenadas $x$ e $y$. 

        Ahora si un enemigo esta a una diferencia con respecto a la coordenada $y$ menor a $T$ del enemigo siguiente , tirando una genkidama a ese enemigo y no al siguiente reduciria en uno la cantidad de genkidamas ha tirar. Si no , si el proximo enemigo esta a una diferencia menor a $T$ en con respecto a la coordenada $x$, podria no tirar una genkidama sobre ese enemigo dejandolo pendiente, y cuando ya no pueda matar al primer enemigo que deje pendiente , tirar una genkidama sobre ese, asi poder ahorarme esos pendientes enemigos. A partir de la ideas recien expuestas, Se pasa a explicar el algoritmo:  


        LLamaremos $maxY$ a el maximo $y$ que cubre el último genkidama, y $xPendiente$ a la coordenada $x$ del primer enemigo que deje pendiente ha eleminar con un futuro genkidama.
        Para el caso $n = 1$ se ha resuelto devolviendo $1$. Para $n > 2$: si el primer enemigo no se puede dejar pendiendte, osea que $x_0 > x_1  - T$, entonces se ha de tirar un genkidama a él y se ha de guardar el maximo $y$ que cubre el genkidama en $maxY$, si no se ha guardar el $x$ del enemigo en $xPendiente$. Para los casos mayores a 1 y menores a $n$ , Si el $maxY$ es menor a la cordenada $y$ del enemigo, entonces si un genkidama tirado a el siguiente enemigo no cubre al anterior, osea $x_i > x_{i+1} - T$,  entonces tiro un genkidama a él , actualizo el maxY e intancio $xPendiente$ en $0$, si no , si $xPendiente$ es $0$ entonces lo reemplazo por la coordenada $x$ del enemigo actual, si un genkidama tirado a el siguiente enemigo no cubre al $xPendiente$, osea  $xPendiente > x_{i+1} - T$, entonces tiro un genkidama a él , actualizo el maxY e intancio $xPendiente$ en $0$. Si el último enemigo no es cubierto por el último genkidama entonces se ha de tirar un genkidama sobre él.

        Quiero ver que expuesto algoritmo cumple cierta propiedad la cual me ayudara a probar correctitud del problema previamente descriptó . Llamaremos $P$ a la propiedad expresada en primer orden , $a$ el array de puntos tomados como input del algoritmo y $S$ el conjunto de enemigos a los cuales se tiraran genkdamas. 
        
        $P(a) = \forall_{0 < i \leq n} ( i \in S  \iff (i = 1 \land |a| = 1 ) \lor ( i = 1  \land (a_{i+1})_x - T  < (a_i)_x ) \lor ( i = n \land (a_i)_y > (a_{i - 1})_y + T ) \lor ( (1 < i < n) \land ( (a_{i+1})_x - T  < (a_i)_x ) ) \land ( (a_i)_y > (a_{i - 1})_y + T ) ) )  $
        
        Hago induccion en el tamaño del $a$ .


        Caso Base : $|a| = 1$, Segun mi algoritmo devuelvo el array $[1]$ , segun la propiedad $P$ tambien.

        Caso Inductivo : $|a| = n$, $a = a' + e $, $|a'| = n - 1$ , Entonces por HI $a'$ cumple $P$. Ahora depende del las coordenadas del nuevo enemigo $e$. 

        Si $e$ tiene la coordenada $x$ más grande y la coordenada $y$ más chicha entonces le cooresponderia la posición $i = 1$, entonces segun el algoritmo si el primer enemigo no se puede dejar pendiendte, osea que $x_0 > x_1  - T$, entonces $1 \in S$ y en $P(a)$ cae en el caso  ($i = 1  \land (a_{i+1})_x - T  < (a_i)_x$) entonces $1 \in S$.





       
    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
         
       

    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

	Se realizaron pruebas experimentales para verificar que el tiempo de ejecución del algoritmo cumpliera con la cota asintótica de $\ord(N)$, teóricamente demostrada para el peor caso. Se realizaron dos tipos de pruebas:
        
        \begin{itemize}
            \item Pruebas con instancias con características particulares, más específicamente, para el caso que se ha de tirar una genkidama y el caso que se ha de tirar $N$ genkidamas .
            \item Pruebas con instancias generadas aleatoriamente, para obtener una aproximación al comportamiento del algoritmo en el caso promedio.
            \item Pruebas fijando un $N$ y variando el T. 
        \end{itemize}

        \subsubsection{Instancias particulares}

            Todas las instancias utilizadas para estas pruebas se generaron de manera aleatoria, pero restringiendo los resultados obtenidos para cumplir con determinadas características. A continuación se enumeran los criterios tenidos en cuenta para la generación de los escenarios de prueba.

            \begin{itemize}
                \item \textbf{Una genkidama:} Para el caso que con un genkidama mate a todos los enemigos , se generaron coordenadas dentro de un rango T , para un enemigo dado. Llamaremos $T2$ al tiempo que tarda en dicho caso.

                \item \textbf{$N$ genkidama:} Para el caso que tenga que matar a cada enemigo con un genkidama, se generaron coordenadas a una distancia mayor a T con respecto a las coordenadas $x$ e $y$ de sus vecinos. Llamaremos $T3$ al tiempo que tarda en dicho caso.

            \end{itemize}

   Para el caso promedio, se generaron coordenadas xs e ys al azar y luego se ordenaron para que cumpla con la descripcion del problema. Llamaremos $T1$ al tiempo que tarda en dicho caso.


    \renewcommand\constante{11.5}

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=red] table[x index=0,y index=1 ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y index=1 ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=green] table[x index=0,y expr={x*\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$T1$, $T2$ , $T3$, $c$ }
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	Se puede ver que en caso $T3$ tiene una constante más pequeña que el resto, esto se debe a que como solo basta un genkidama para matar a todos los enemigos , despues de tirar ese genkidama los siguiente puntos solo verifican que ya esten cubiertos .

	El caso $T2$ tiene una constante más grande ya que siempre se ha de agregar un genkidama , entonces se ha de verifcar si el anterior y el siguiente lo cubren. 

	El caso $T3$ es el que peor constante tiene , ya que hay veces que llega a tener entrar al mayor numero de condicionantes posibles.

	Los tres $Ts$ son acotados por $c$ que es $11.5 * x$ lo cual demuestra que la complejidad es cualquiera de los casos planteados es lineal. 

	
	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=red] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=black] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=green] table[x index=0, y expr={\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$\frac{T1}{N}$, $\frac{T2}{N}$, $\frac{T3}{N}$ , $c$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la $figura 5$ se ve que si divimos los $Ts$ por $n$ y se puede acotar por $c$ que es $11.5$.

	

	Para ver que variando el $T$ afecta en una constante la complejidad del algoritmo, se fijo un número de enemigos($10000$) y se hizo variar el $T$,las coordenadas se dispucieron en a lo sumo distancia $x$ e $y$ $T'$ ($50$), para ver que despues de cierto $t$ cae en el caso que con un genkidama mata a todos los enemigos y converge a una constante.  

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($T$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_variar_T_output};
				\legend{$T$ }
			\end{axis}
		\end{tikzpicture}
	\end{figure}

