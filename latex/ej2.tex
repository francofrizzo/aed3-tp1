
\section{Ejercicio 2}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
	\subsection{Descripción del problema}

	$N$ soldados de Freezer estan parados en distintos puntos $(X_i,Y_i)$ sobre
	nuestro planeta y estan dispuestos a acabar con toda la humanidad. Para
	esto, Gokú desea lanzarles Genkidamas para acabar con ellos. Los puntos
	cumplen con la propiedad $ X_1 > X_2 >. . . > X_N \geq 0 $ y $ 0 \leq Y_1 <
	Y_2 < . . . < Y_N$. Una Genkidama lanzada al objetivo con coordenadas $(X,Y)$
	destruye a todos los enemigos que estan en el rectángulo con lados paralelos
	a los ejes y extremos en $(0, 0)$ y $(X + T, Y + T )$. Sólo pueden lanzarse
	Genkidamas a puntos donde hay o hubo un enemigo. 

	La solución al problema debe tomar un $N$ correspondiente a la cantidad de adversarios,
	$T$ el alcance de la Genkidama, y por último las posiciones de los enemigos
	de Gokú. Con estos datos calculará a qué enemigos lanzarles una
	Genkidama para requerir las mínimas posibles.

	La salida consiste en un $G$ que representa la cantidad de Genkidamas
	seguido de una línea con los índices de los adversarios a los cuáles se
	les lanzó alguna.

	Este es un ejemplo de una entrada con su respectiva
	solución:

	~

	\textbf{Entrada}

	\begin{tabular}{ll}
		\texttt{3} & \texttt{2} \\
		\texttt{4} & \texttt{0} \\
		\texttt{3} & \texttt{3} \\
		\texttt{1} & \texttt{6} \\
	\end{tabular}

	~

	\textbf{Salida}

	\begin{tabular}{ll}
		\texttt{2} & \\
		\texttt{2} & \texttt{3} \\
	\end{tabular}

	~

	Se puede observar que tenemos 3 oponentes ($N$), el rango de la
	Genkidama es 2 ($T$) y se necesitaron 2 de ellas para vencerlos ($G$). En este caso, al
	dispararle a 2 se estaba también destruyendo a 1, quedando fuera del alcance
	y por ende destinado a ser exterminado aparte 3.

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}

	Si se le dedicara una Genkidama a cada oponente se resolvería el problema de
	destruir al enemigo, pero no sería una estrategia óptima para cualquier
	caso. Únicamente daría el valor óptimo para el caso donde el área de cobertura de cada
	Genkidama no fuera suficiente para alcanzar otros adversarios. Por lo tanto
	es necesario considerar cuándo al eliminar un oponente se está a su vez
	destruyendo a otros.

	Para este problema en particular se encontró un algoritmo goloso que genera
	la solución óptima con una complejidad temporal lineal. La idea detrás de
	esta solución y la cual la caracteriza como golosa consiste en que la
	decisión sobre si utilizar una Genkidama depende únicamente del
	elemento (refiriéndonos a las coordenadas de un adversario) a continuación y dos
	enteros que ofrecen información sobre los enemigos recorridos anteriormente.

	Al observar el elemento a continuación, se puede saber si al lanzarle una
	Genkidama a este, la misma alcanza al enemigo actual. Sin embargo no
	es tan sencillo, y aquí es donde se utilizan los dos enteros mencionados con
	anterioridad. Uno de los enteros es $maxY = Y_{E_j} + T$, donde lo que se
	almacena es la coordenada $Y$ de la última Genkidama lanzada más su alcance
	$T$, necesaria para saber si mi adversario actual se encuentra bajo el
	alcance de alguna Genkidama anterior. El otro es $xPendiente$ cuya función
	es guardar el valor de la coordenada $X$ de un oponente que está en el
	rango del que le sigue, quedando así pendiente a ser destruido por una
	Genkidama lanzada a algún sucesor.

	Habiendo introducido la idea, se detalla el comportamiento del algoritmo para
	una entrada con $N$ enemigos y rango de Genkidama $T$. Tanto $maxY$ como
	$xPendiente$ son inicializados en 0.

	\begin{enumerate}
		\item{
			El primer elemento es analizado por separado ya que no requiere
			revisar si un elemento anterior lo cubre, por lo tanto para este lo
			único que es necesario hacer es observar si en caso de haber un elemento
			siguiente, este lo cubre. Si es así, entonces no se agrega al primero a
			la solución y $xPendiente = X_1$. Caso contrario, si no lo cubre el
			siguiente, se agrega al primero a la solución y $maxY = Y_1 + T$.
		}

		\item{
			Si $N > 1$ entonces se procede al ciclo principal que recorrerá los
			elementos $E_j$ con $1 < j < N$ dado que el último enemigo al igual
			que el primero se trata aparte. Dentro de este ciclo se tienen
			varios casos posibles:
			\begin{enumerate}
				\item{
					La coordenada $Y_{E_j} \leq maxY$, con lo cual $E_j$ está
					dentro del alcance de una Genkidama anterior por lo tanto no
					es necesario agregarlo a la solución (dispararle una
					Genkidama).
					}
				\item{
					La coordenada $Y_{E_j} > maxY$. Si $xPendiente = 0$ entonces
					debo actualizarlo con $xPendiente = X_{E_j}$. Esto se debe a
					que no había ningún enemigo pendiente, por lo tanto $E_j$
					pasa a estarlo. De aquí se abren más posibilidades:
					\begin{enumerate}
						\item{Si $X_{E_j} > X_{E_{j+1}} + T$ entonces $E_j$ no
							se encuentra en el rango de su sucesor por lo tanto
							debe ser agregado. Se asignan $xPendiente = 0$ y
							$maxY = Y_{E_j} + T$.}
						\item{Si $X_{E_j} \leq X_{E_{j+1}} + T$ entonces se
							encuentra en el rango de su sucesor para lo cual
							existen dos casos:}
						\begin{enumerate}
							\item{$X_{E_{j+1}} + T < xPendiente$ donde a pesar
								de estar en el rango del sucesor, el mismo no
								alcanza a un enemigo que quedó dependiendo de
								una futura Genkidama, por lo tanto debo agregar
								a $E_j$. Se asignan $xPendiente = 0$ y $maxY = Y_{E_j} + T$.}
							\item{$X_{E_{j+1}} + T \geq xPendiente$ donde el
								sucesor además de alcanzar a $E_j$ también llega
								al que quedó pendiente, por lo tanto no es
								necesario agregar a $E_j$.}
						\end{enumerate}
					\end{enumerate}
					}
				\end{enumerate}
		}
		\item{
			Finalmente, para el último elemento se tiene que únicamente
			es necesario agregarlo cuando $Y_{E_N} > yMax$, ya que
			implica que no está cubierto por la Genkidama de algún
			elemento anterior. Si $Y_{E_N} \leq yMax$, entonces no es
			necesario sumarlo a la solución, y no hace falta revisar
			$xPendiente$ ya que si la última Genkidama alcanza para
			cubrir $E_N$, por las condiciones que establece el
			enunciado necesariamente estarán cubiertos los elementos en
			el medio ($(\forall j < N) Y_j < E_N$).}

	\end{enumerate}

    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
         
       

    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    \subsection{Experimientacion}
         

	Se realizaron pruebas experimentales para verificar que el tiempo de ejecución del algoritmo cumpliera con la cota asintótica de $\ord(N)$, teóricamente demostrada para el peor caso. Se realizaron dos tipos de pruebas:
        
        \begin{itemize}
            \item Pruebas con instancias con características particulares, más específicamente, para el caso que se ha de tirar una genkidama y el caso que se ha de tirar $N$ genkidamas .
            \item Pruebas con instancias generadas aleatoriamente, para obtener una aproximación al comportamiento del algoritmo en el caso promedio.
            \item Pruebas fijando un $N$ y variando el T. 
        \end{itemize}

        \subsubsection{Instancias particulares}

            Todas las instancias utilizadas para estas pruebas se generaron de manera aleatoria, pero restringiendo los resultados obtenidos para cumplir con determinadas características. A continuación se enumeran los criterios tenidos en cuenta para la generación de los escenarios de prueba.

            \begin{itemize}
                \item \textbf{Una genkidama:} Para el caso que con un genkidama mate a todos los enemigos , se generaron coordenadas dentro de un rango T , para un enemigo dado. Llamaremos $T_2$ al tiempo que tarda en dicho caso.

                \item \textbf{$N$ genkidamas:} Para el caso que tenga que matar a cada enemigo con un genkidama, se generaron coordenadas a una distancia mayor a T con respecto a las coordenadas $x$ e $y$ de sus vecinos. Llamaremos $T_3$ al tiempo que tarda en dicho caso.

                \item \textbf{$T$ no afecta la complejidad:}Para ver que variando el $T$ no afecta la complejidad del algoritmo, se fijo un número de enemigos ($10000$) y se hizo variar el $T$.


            \end{itemize}

   Para el caso promedio, se generaron coordenadas xs e ys al azar y luego se ordenaron para que cumpla con la descripcion del problema. Llamaremos $T1$ al tiempo que tarda en dicho caso.


    \renewcommand\constante{11.5}

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_base}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=red] table[x index=0,y index=1 ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y index=1 ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=green] table[x index=0,y expr={x*\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$T_1$, $T_2$ , $T_3$, $c$ }
			\end{axis}
		\end{tikzpicture}
	\end{figure}
	En la Figura \ref{fig:exp2:part_tiempo_base} se puede ver :

	     \begin{itemize} 
            \item El caso $T_1$ es el que peor constante tiene , ya que hay veces que llega a tener entrar al mayor numero de condicionantes posibles.
            \item 	El caso $T_2$ tiene una constante más grande ya que siempre se ha de agregar un genkidama , entonces se ha de verifcar si el anterior y el siguiente lo cubren.  
             \item Se puede ver que en caso $T_3$ tiene una constante más pequeña que el resto, esto se debe a que como solo basta un genkidama para matar a todos los enemigos , despues de tirar ese genkidama los siguiente puntos solo verifican que ya esten cubiertos .
            \item Los tres $Ts$ son acotados por $c$ que es $11.5 * x$ lo cual demuestra que la complejidad es cualquiera de los casos planteados es lineal. 
        \end{itemize}


	

	
	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=red] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=black] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=green] table[x index=0, y expr={\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$\frac{T_1}{N}$, $\frac{T_2}{N}$, $\frac{T_3}{N}$ , $c$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:exp2:part_tiempo_sobre_n} se ve que si divimos los $Ts$ por $n$ y se puede acotar por $c$ que es $11.5$.


	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_base_var_T}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($T$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_variar_T_output};
				\legend{$T$ }
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:exp2:part_tiempo_base_var_T} que converge a una constanste .

	 El análisis expuesto de los datos recopilados presenta evidencia empírica sobre la pertinencia la cota de complejidad demostrada teóricamente. Más aún, permite llegar a la conclusión que, incluso en las instancias de peor caso, esta cota resulta holgada, es decir, que la complejidad del algoritmo presentado es estrictamente $\ord(N)$. Ademas se logro ver que la complejidad depende estrictamente del la cantidad de enemigos ha eliminar y no del tamaño de $T$ .



