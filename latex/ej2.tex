
\section{Ejercicio 2}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
	\subsection{Descripción del problema}

	$N$ soldados de Freezer estan parados en distintos puntos $(X_i,Y_i)$ sobre
	nuestro planeta y estan dispuestos a acabar con toda la humanidad. Para
	esto, Gokú desea lanzarles Genkidamas para acabar con ellos. Los puntos
	cumplen con la propiedad $ X_1 > X_2 >. . . > X_N \geq 0 $ y $ 0 \leq Y_1 <
	Y_2 < . . . < Y_N$. Una Genkidama lanzada al objetivo con coordenadas $(X,Y)$
	destruye a todos los enemigos que estan en el rectángulo con lados paralelos
	a los ejes y extremos en $(0, 0)$ y $(X + T, Y + T )$. Sólo pueden lanzarse
	Genkidamas a puntos donde hay o hubo un enemigo. 

	La solución al problema debe tomar un $N$ correspondiente a la cantidad de adversarios,
	$T$ el alcance de la Genkidama, y por último las posiciones de los enemigos
	de Gokú. Con estos datos calculará a qué enemigos lanzarles una
	Genkidama para requerir las mínimas posibles.

	La salida consiste en un $G$ que representa la cantidad de Genkidamas
	seguido de una línea con los índices de los adversarios a los cuáles se
	les lanzó alguna.

	Este es un ejemplo de una entrada con su respectiva
	solución:

	~

	\textbf{Entrada}

	\begin{tabular}{ll}
		\texttt{3} & \texttt{2} \\
		\texttt{4} & \texttt{0} \\
		\texttt{3} & \texttt{3} \\
		\texttt{1} & \texttt{6} \\
	\end{tabular}

	~

	\textbf{Salida}

	\begin{tabular}{ll}
		\texttt{2} & \\
		\texttt{2} & \texttt{3} \\
	\end{tabular}

	~

	Se puede observar que tenemos 3 oponentes ($N$), el rango de la
	Genkidama es 2 ($T$) y se necesitaron 2 de ellas para vencerlos ($G$). En este caso, al
	dispararle a 2 se estaba también destruyendo a 1, quedando fuera del alcance
	y por ende destinado a ser exterminado aparte 3.

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}
        Si tirara un genkidama a cada enemigo eso solucionaria el problema de matar a todos los enemigos, pero solo seria solucion optima si todos los enemigos estuviesen a una distancia mayor a $\sqrt{2}T$ , ya que cada enemigo tendria una diferencia mayor a $T$ con respecto a las coordenadas $x$ e $y$. 

        Ahora si un enemigo esta a una diferencia con respecto a la coordenada $y$ menor a $T$ del enemigo siguiente , tirando una genkidama a ese enemigo y no al siguiente reduciria en uno la cantidad de genkidamas ha tirar. Si no , si el proximo enemigo esta a una diferencia menor a $T$ en con respecto a la coordenada $x$, podria no tirar una genkidama sobre ese enemigo dejandolo pendiente, y cuando ya no pueda matar al primer enemigo que deje pendiente , tirar una genkidama sobre ese, asi poder ahorarme esos pendientes enemigos. A partir de la ideas recien expuestas, Se pasa a explicar el algoritmo:  


        LLamaremos $maxY$ a el maximo $y$ que cubre el último genkidama, y $xPendiente$ a la coordenada $x$ del primer enemigo que deje pendiente ha eleminar con un futuro genkidama.
        Para el caso $n = 1$ se ha resuelto devolviendo $1$. Para $n > 2$: si el primer enemigo no se puede dejar pendiendte, osea que $x_0 > x_1  - T$, entonces se ha de tirar un genkidama a él y se ha de guardar el maximo $y$ que cubre el genkidama en $maxY$, si no se ha guardar el $x$ del enemigo en $xPendiente$. Para los casos mayores a 1 y menores a $n$ , Si el $maxY$ es menor a la cordenada $y$ del enemigo, entonces si un genkidama tirado a el siguiente enemigo no cubre al anterior, osea $x_i > x_{i+1} - T$,  entonces tiro un genkidama a él , actualizo el maxY e intancio $xPendiente$ en $0$, si no , si $xPendiente$ es $0$ entonces lo reemplazo por la coordenada $x$ del enemigo actual, si un genkidama tirado a el siguiente enemigo no cubre al $xPendiente$, osea  $xPendiente > x_{i+1} - T$, entonces tiro un genkidama a él , actualizo el maxY e intancio $xPendiente$ en $0$. Si el último enemigo no es cubierto por el último genkidama entonces se ha de tirar un genkidama sobre él.

        Quiero ver que expuesto algoritmo cumple cierta propiedad la cual me ayudara a probar correctitud del problema previamente descriptó . Llamaremos $P$ a la propiedad expresada en primer orden , $a$ el array de puntos tomados como input del algoritmo y $S$ el conjunto de enemigos a los cuales se tiraran genkdamas. 
        
        $P(a) = \forall_{0 < i \leq n} ( i \in S  \iff (i = 1 \land |a| = 1 ) \lor ( i = 1  \land (a_{i+1})_x - T  < (a_i)_x ) \lor ( i = n \land (a_i)_y > (a_{i - 1})_y + T ) \lor ( (1 < i < n) \land ( (a_{i+1})_x - T  < (a_i)_x ) ) \land ( (a_i)_y > (a_{i - 1})_y + T ) ) )  $
        
        Hago induccion en el tamaño del $a$ .


        Caso Base : $|a| = 1$, Segun mi algoritmo devuelvo el array $[1]$ , segun la propiedad $P$ tambien.

        Caso Inductivo : $|a| = n$, $a = a' + e $, $|a'| = n - 1$ , Entonces por HI $a'$ cumple $P$. Ahora depende del las coordenadas del nuevo enemigo $e$. 

        Si $e$ tiene la coordenada $x$ más grande y la coordenada $y$ más chicha entonces le cooresponderia la posición $i = 1$, entonces segun el algoritmo si el primer enemigo no se puede dejar pendiendte, osea que $x_0 > x_1  - T$, entonces $1 \in S$ y en $P(a)$ cae en el caso  ($i = 1  \land (a_{i+1})_x - T  < (a_i)_x$) entonces $1 \in S$.





       
    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
         
       

    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    % 5. Realizar una experimentación computacional para medir la performance del programa implementado. Usar un conjunto de casos de test en función de los parámetros de entrada, con instancias aleatorias e instancias particulares (de peor/mejor caso en tiempo de ejecución, por ejemplo). Presentar en forma gráfica una comparación entre los tiempos medidos y la complejidad teórica calculada y extraer conclusiones.
    \subsection{Experimentación}
