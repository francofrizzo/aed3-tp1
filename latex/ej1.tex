\section{Ejercicio 1}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
    \subsection{Descripción del problema}
        Gokú debe entrenar un ejército de $N$ guerreros para enfrentarse a Majin Boo. Para lograr ese objetivo, desea organizar peleas entre sus luchadores. En cada pelea, los guerreros serán divididos en dos bandos que pelearán entre sí. El objetivo es que, para cualquier par de luchadores, haya al menos una pelea en la que se encuentren en bandos distintos. Al mismo tiempo, el número total de peleas debe ser el mínimo necesario.

        La resolución del problema consiste en elaborar un programa que recibe como entrada el valor de $N$, y devuelve la cantidad mínima de peleas que deben llevarse a cabo para cumplir el cometido de Gokú y a continuación, por cada una de las peleas, una línea indicando el bando al que pertenece cada uno de los luchadores durante la misma. De haber más de una solución posible, puede devolverse cualquiera de ellas.

        Por ejemplo, si el programa recibe como entrada el valor \texttt{8}, cualquiera de las siguientes tres salidas sería correcta:

        \begin{center}\begin{tabular}{l @{\hskip 2em} | @{\hskip 2em} l @{\hskip 2em} | @{\hskip 2em} l}
            \texttt{3}               & \texttt{3}  &              \texttt{3}               \\
            \texttt{1 1 1 1 2 2 2 2} & \texttt{1 1 2 2 2 1 2 1} & \texttt{2 1 1 1 2 1 2 2} \\
            \texttt{1 1 2 2 1 1 2 2} & \texttt{1 1 2 1 2 2 1 2} & \texttt{1 2 1 1 2 2 2 1} \\
            \texttt{1 2 1 2 1 2 1 2} & \texttt{2 1 2 1 1 1 2 2} & \texttt{1 1 2 1 2 2 1 2} \\
        \end{tabular}\end{center}

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}
        La solución que se propone para el problema resulta más fácil de comprender con un sencillo cambio de óptica. En lugar de entender una solución como una sucesión de peleas, donde a cada una de ellas le corresponde una lista representando a un peleador, puede pensarse en una asignación entre cada guerrero y su \emph{historial de peleas}: la lista de los bandos que le fueron asignados en cada una de las peleas. Por ejemplo, si el historial de peleas de un guerrero es \texttt{2122}, esto significa que en la primera, la tercera y la cuarta pelea formó parte del bando número 2, mientras que en el segundo enfrentamiento peleó en el bando número 1. En una solución presentada según el formato requerido, los historiales de peleas de cada guerrero pueden verse si se la lee por columnas.

        Para que una solución al problema sea válida, es necesario cualquier par de peleadores diferentes se enfrente al menos en una pelea. Puede observarse que esto equivale a que el historial de peleas asignado a cada guerrero sea distinto, es decir, que difiera como mínimo en un dígito de todos los demás. Por otro lado, se pide que se lleve a cabo el mínimo número de peleas necesario, o lo que es lo mismo, que la longitud de los historiales de peleas sea la menor posible.

        Observando el problema desde esta perspectiva, es posible apreciar su semejanza con la construcción de un sistema de numeración posicional. Mientras que en un sistema de numeración se busca representar a los números naturales mediante una serie finita de símbolos provenientes de un alfabeto también finito, en una solución al problema planteado se busca asignar a cada peleador un historial de peleas, que consiste también en una serie finita de elementos de un conjunto finito: los bandos 1 y 2. Además, en un sistema de numeración, la representación de cada número tiene, en cierto sentido, la mínima longitud posible: estas se van asignando en orden creciente, y si queda ``libre'' una representación de cinco dígitos para un número, se utiliza esta antes que una de seis. Esto se parece al requisito de optimalidad requerido por el problema. Por último, dados dos números distintos, es necesario que sus representaciones en un sistema de numeración difieran como mínimo en un dígito, de forma análoga a lo que se desea que suceda con los historiales de peleas de dos guerreros diferentes.

        El sistema de numeración binario utiliza, comúnmente, los símbolos 0 y 1. Sin embargo, esta elección es completamente arbitraria. Si se piensa en una variante de este sistema construida en base a los símbolos 1 y 2, el problema de asignar un historial de peleas para $N$ guerreros que cumpla los requerimientos de Gokú puede reducirse a encontrar una representación en dicho sistema para los primeros $N$ números naturales. (A modo ilustrativo, pueden observarse las columnas de las soluciones de ejemplo expuestas en la descripción del problema. Si se reemplazan los símbolos $\lbrace1,2\rbrace$ por $\lbrace1,0\rbrace$, las columnas corresponden exactamente a la escritura binaria de los números entre 0 y 7).

    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
         
      Se tiene una matriz de $log(n)$ filas por $n$ columnas, se inicializa la matriz en 1, eso cuesta $nlog(n)$ . Para generar las peleas se recorre la matriz: se tiene un ciclo que recorre las filas, dentro del mismo se tiene dos ciclos anidados que se encargan de recorrer las columnas. Para recorrer las columnas : el primer ciclo va hasta $n$ de saltos de a $2^i$ ($\frac{n}{2^i}$ iteraciones), el ciclo anidado va hasta $2^i$ con saltos de a 1 ($2^i$ iteraciones).

      Entonces la complejidad de los tres ciclos es $\sum_{i = 0}^{log(n)} \sum_{j = 0}^{\frac{n}{2^i}}  2^i = \sum_{i = 0}^{log(n)} \frac{n}{2^i} * 2^i = \sum_{i = 0}^{log(n)} n = nlog(n)$. Se puede concluir que la complejidad del algoritmo es $O(nlog(n))$. 


    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    % 5. Realizar una experimentación computacional para medir la performance del programa implementado. Usar un conjunto de casos de test en función de los parámetros de entrada, con instancias aleatorias e instancias particulares (de peor/mejor caso en tiempo de ejecución, por ejemplo). Presentar en forma gráfica una comparación entre los tiempos medidos y la complejidad teórica calculada y extraer conclusiones.
    \subsection{Experimentación}

	A la hora de medir el rendimiento del algoritmo y confirmar la complejidad
	teórica se tuvieron que considerar varios aspectos tales que los
	resultados de la experimentación reflejaran lo mejor posible su
	comportamiento.

	Dado que el problema consiste en una única entrada, los casos de prueba
	posibles se reducen al conjunto de los números enteros positivos. Como la
	complejidad temporal del algoritmo es $\theta(Nlog(N))$, no hay un peor
	y mejor escenario, por lo tanto no es necesario establecer condiciones sobre
	la entrada.

	El experimento consiste en la medición de los tiempos de ejecución para
	entradas cada vez más grandes. A continuación se describen las condiciones aplicadas
	para el mismo:

	\begin{itemize}
		\item{Como entrada se utilizó $N = 2^{k}$ con $0 < k < 24.$}
		\item{Por cada $N$, se repitió 10 veces la medición y se calculó un
			promedio.}
		\item{Sólo se midió el costo temporal de generar la solución, no
			de lectura y escritura del problema.}
		\item{Para la medición del tiempo se utilizó la librería \texttt{chronos}
			con unidad de tiempo en nanosegundos.}
	\end{itemize}

	De estos puntos, cabe destacar la elección de potencias de dos como
	entrada. Esta decisión surge del hecho de que en valores pequeños las
	mediciones de tiempo son más sensibles a perturbaciones del sistema en el
	que están corriendo. Al elegir $N = 2^{k}$ como entrada tenemos que para los
	primeros valores de $k$, los $N$ resultantes se encuentran relativamente
	concentrados, logrando así un muestreo que caracterice mejor estos valores.
	A medida que se aumenta el $k$, obtenemos valores de entrada más espaciados
	con tamaños donde el ruido introducido por el sistema es despreciable.

	Los resultados obtenidos fueron los siguientes:

	\newcommand\constante{30}
	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_base}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=1]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={x*ln(x)*\constante}]{../exp/kaioKenOutput};
				\legend{$T$, $c*N*log(N)$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:tiempo_base} se puede observar como la curva generada por el
	tiempo de ejecución puede ser acotada para un $c$ fijo por una función
	$c*N*log(N)$. Para ratificar esta observación se procede dividiendo cada $T$
	por su respectivo $N$ con la intención de generar una curva de forma
	logarítmica.

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymax=500,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=2]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={ln(x)*\constante}]{../exp/kaioKenOutput};
				\legend{$\frac{T}{N}$, $c*log(N)$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	Con la Figura \ref{fig:tiempo_sobre_n} se corrobora lo previsto, ya que
	efectivamente se puede apreciar cómo con la misma constante $c$ se puede
	acotar por una función $c*log(N)$.

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n_log_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					ymax=150,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=3]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={\constante}]{../exp/kaioKenOutput};
				\legend{$\frac{T}{N*log(N)}$, $c$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	Finalmente, en la Figura \ref{fig:tiempo_sobre_n_log_n} se tiene que
	$\frac{T}{N*log(N)}$ converge a una constante que es acotada por el $c$
	utilizado en las figuras anteriores.

	Es así como se llega a la conclusión de que efectivamente la complejidad
	temporal de la solución desarrollada coincide con la complejidad teórica estipulada.

	Para reproducir los datos utilizados basta con ejecutar \texttt{KaioKenSolver
	-p}.
